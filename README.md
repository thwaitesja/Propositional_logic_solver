# Propositional_logic_solver
This is a python script that generates a class that can pass in any string of propositional logic and it will be able to give you information about the propositional expression or expressions. I completed this for my Discrete Math Final Project. More technically this class takes a string of propositional logic and converts it into a Z3 solver object. It also is able to tell if the inputted expression or expressions is satisfiable or unsatisfiable. This project has the functionality of many different  propositional logic symbols. It even has multiple representations on some common ones such as “!” and “~” both meaning not, this helps broaden the usability of this code for many different users of different backgrounds. I also included many different more obscure operators such as xor “^”, and implies “->” allow a greater form of expression through the strings. This project also has added robustness by removing the importance of spaces and removing the importance of capital letters, so “a&b” is the same as “A&  b”.

The motivation for this project was to simplify Z3 to be a tool that can be used for any type of propositional logic with a much more intuitive interface for simple applications without the need for understanding how to use Z3. This way The only thing that anyone needs to know to use my extension is how to write the boolean equations for whatever they are trying to solve. This then can be inputted into the object and evaluated. The script will be able to either print all the options, or it will be able to tell you whether a variable needs to be true, false or either to make a certain equation satisfiable. 

Provided at the bottom of the python script is an example of this object being used. It is being used on the Python section of homework 3. In this problem the user needed to determine the guilt of two prisoners based on talking to some knights and knaves. In this example the user would simply need to create a logic solver object, and then they can just add each statement as its own string into the logic solver. Then they just need to print out the variable specs for the desired variables, in this case v and w, and based off of this program will print out what can be determined about v and w- in this case that they are guilty.

The goals discussed in my project proposal were lofty and I realized that as soon as I got started with the word processing. This was the major hurdle through this project and I ended up spending quite a few hours to get a very compact working version of this through my function “listify”. This function allows the user to work through a string of equations and at each pass simplify a part of the string for the next iteration. I determined that as long as this function continued to have some form of reduction in the character list, then the function may loop for a while, but it will end at some point. I was able to change my focus from adding on predicate logic to instead adding on the usability of the propositional logic solver. This seemed like a much more achievable scope because predicate logic is more complex than propositional logic, therefore it would need require me to develop a second language parser, which would be equivalent to completing two projects. Instead, I used a few of Python’s built in string methods to increase the vocabulary, giving many characters aliases since propositional logic is taught with a large amount of different symbols depending on who is teaching ( or can be “+” or “|”, and can be “*” or “&”).

I am quite happy with how this project turned out. I feel like this would be a helpful code for a student who is just about to start discrete math. This would help in changing the learning curve that comes with Z3. I also feel like this is a useful tool when it comes to any form of logic variable simplification. This functionality shows through when using the output functions. For instance, it is very helpful to get a feel for all the possible combinations of solutions for a given expression. This can be outputted through the print_options method. While if there are a large amount of variables and you only care about one or two, then variable specs will allow for the user to check if the variable can be implemented as either true or false or if it is constrained.

I have also included a few errors and debugging tools for the propositional logic generator. The main implementation of this is parentheses checking that makes sure that any inputted string has balanced parentheses. This way if an error is thrown the user will know this is because of a malformed input in their parentheses and know how to fix this. 

The basic way to use this code is at the bottom of the script call an instantiation of the LogicSolver object. There are no needed inputs to the LogicSolver initialization, however you can pass your propositional logic string argument in at this point. If you wish to add additional propositional logic constraint strings, they can be added with the .add_string() method, then when the user wishes to get the output, they can they have many options:
print(Instance Name) if inputted into the print function, it will state if it is satisfiable or unsatisfiable
.returnSolver() returns the actual Z3 solver for Z3 functionality
.count_model() counts the number of possible solutions *generally grows exponentially for the number of variables (can be slow)
.print_options() prints all of possible solution combinations *generally grows exponentially for the number of variables (can be slow)
.isTautology() is true if the statements are a Tautology
.print_options() allows user to select which variables to see if the logic equations constrain them to be true or false
There are examples of these in the python script which are commented to show the various options for different scenarios.

